-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      fn = fun (l, op, r) { Binop (op, l, r) },
      exp = expr(
        { [Left, {[s("!!"), fn]}],
          [Left, {[s("&&"), fn]}],
          [Nona, {[s("=="), fn],
                  [s("!="), fn],
                  [s("<="), fn],
                  [s(">="), fn],
                  [s("<"),  fn],
                  [s(">"),  fn]
                 }],
          [Left, {[s("+"),  fn],
                  [s("-"),  fn]
                 }],
          [Left, {[s("*"),  fn],
                  [s("/"),  fn],
                  [s("%"),  fn] 
                 }]}, 
        primary);

var elseBranchParser = memo $ eta syntax (
    kFi { Skip } |
    kElse st=stmt kFi { st } |
    kElif e=exp kThen st=stmt els=elseBranchParser { If (e, st, els) } 
  );

var simple_stmt = memo $ eta syntax  (
    kSkip                                                    { Skip } |
    x=lident s[":="] e=exp                                   { Assn (x, e)} |
    kRead  x=inbr[s("("), lident, s(")")]                    { Read (x) } | 
    kWrite e=inbr[s("("), exp,    s(")")]                    { Write (e) } |
    kIf e=exp kThen st=stmt els=elseBranchParser             { If (e, st, els) } |
    kWhile e=exp kDo st=stmt kOd                             { While (e, st) } |
    kDo st=stmt kWhile e=exp kOd                             { DoWhile (st, e) } |
    kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd { Seq (s1, While (e, Seq (s3, s2))) }
  ),
  stmt = memo $ eta syntax (simple_stmt | s1=simple_stmt s[";"] s2=stmt { Seq (s1, s2) });
   

-- Public top-level parser
public parse = stmt;
             